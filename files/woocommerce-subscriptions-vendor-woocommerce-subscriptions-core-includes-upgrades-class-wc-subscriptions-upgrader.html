<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WooCommerce Code Reference</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../images/favicon.png" />
    <link rel="apple-touch-icon" href="../images/apple-touch-icon.png"/>
    <link rel="apple-touch-icon" sizes="72x72" href="../images/apple-touch-icon-72x72.png"/>
    <link rel="apple-touch-icon" sizes="114x114" href="../images/apple-touch-icon-114x114.png"/>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/base.css?updated=1663738776">
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/template.css?updated=1663738776">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/css/all.min.css" integrity="sha256-ybRkN9dBjhcS2qrW1z+hfCxq+1aBdwyQM5wlQoQVt/0=" crossorigin="anonymous" />
            <script src="https://cdn.jsdelivr.net/npm/css-vars-ponyfill@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/js/all.min.js" integrity="sha256-0vuk8LXoyrmCjp1f0O300qo1M75ZQyhH9X3J6d+scmk=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tarekraafat/autocomplete.js@7.2.0/dist/js/autoComplete.min.js"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8KCYZ2CYMS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8KCYZ2CYMS', {
		'content_group' : 'WooCommerce Core Code Reference',
	});
</script>
        <script src="../js/prism.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            window.dispatchEvent(new HashChangeEvent('hashchange'));
        });
    </script>
</head>
<body id="top">
    <header class="phpdocumentor-top-header">
    <section class="phpdocumentor-section">
        <div class="site-branding">
            <a class="site-logo" href="../index.html"><img width="180" src="../images/logo.svg" alt="WooCommerce" /></a>
        </div>
        <nav class="main-navigation">
            <ul>
                <li><a href="../hooks/hooks.html">Hooks Reference</a></li>
                <li><a href="https://docs.woocommerce.com/">Documentation</a></li>
                <li><a href="https://woocommerce.github.io/woocommerce-rest-api-docs/">REST API Docs</a></li>
                <li><a href="https://woocommerce.com/careers/?utm_source=woocommerce+core+code+reference&utm_medium=devdocs&utm_campaign=woo+careers" target="_blank">We're hiring!</a></li>
            </ul>
        </nav>
    </section>
</header>

<div class="phpdocumentor-header">
    <section class="phpdocumentor-section">
        <h1 class="phpdocumentor-title">WooCommerce Code Reference</h1>
        <section class="phpdocumentor-search">
    <label class="phpdocumentor-label">
        <span class="visually-hidden">Search (click ESC to close search results)</span>
        <input id="autoComplete" tabindex="1" type="search" class="phpdocumentor-field phpdocumentor-search__field" placeholder="Loading..." disabled />
    </label>
</section>

    </section>
</div>

    <main class="phpdocumentor">
        <div class="phpdocumentor-section">
            <aside class="phpdocumentor-column -four phpdocumentor-sidebar">
    
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Namespaces</h2>
            </section>

        <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Packages</h2>
                    <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsAdmin.html"><abbr title="\WooCommerceSubscriptionsAdmin">WooCommerceSubscriptionsAdmin</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsClasses.html"><abbr title="\WooCommerceSubscriptionsClasses">WooCommerceSubscriptionsClasses</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptions.html"><abbr title="\WooCommerceSubscriptions">WooCommerceSubscriptions</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="../packages/WooCommerceSubscriptions-WC.html"><abbr title="\WooCommerceSubscriptions\WC">WC</abbr></a></li>
                                    <li><a href="../packages/WooCommerceSubscriptions-RestApi.html"><abbr title="\WooCommerceSubscriptions\RestApi">RestApi</abbr></a></li>
                                    <li><a href="../packages/WooCommerceSubscriptions-WCS.html"><abbr title="\WooCommerceSubscriptions\WCS">WCS</abbr></a></li>
                                    <li><a href="../packages/WooCommerceSubscriptions-GatewaysPayPal.html"><abbr title="\WooCommerceSubscriptions\GatewaysPayPal">GatewaysPayPal</abbr></a></li>
                                    <li><a href="../packages/WooCommerceSubscriptions-Privacy.html"><abbr title="\WooCommerceSubscriptions\Privacy">Privacy</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerce.html"><abbr title="\WooCommerce">WooCommerce</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="../packages/WooCommerce-SubscriptionsAPI.html"><abbr title="\WooCommerce\SubscriptionsAPI">SubscriptionsAPI</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-SubscriptionsIncludesEmails.html"><abbr title="\WooCommerce\SubscriptionsIncludesEmails">SubscriptionsIncludesEmails</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-SubscriptionsClassesEmails.html"><abbr title="\WooCommerce\SubscriptionsClassesEmails">SubscriptionsClassesEmails</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WC.html"><abbr title="\WC">WC</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="../packages/WC-Subscriptions.html"><abbr title="\WC\Subscriptions">Subscriptions</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsAdminUpgrades.html"><abbr title="\WooCommerceSubscriptionsAdminUpgrades">WooCommerceSubscriptionsAdminUpgrades</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsFunctions.html"><abbr title="\WooCommerceSubscriptionsFunctions">WooCommerceSubscriptionsFunctions</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsAdminMetaBoxes.html"><abbr title="\WooCommerceSubscriptionsAdminMetaBoxes">WooCommerceSubscriptionsAdminMetaBoxes</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsAbstracts.html"><abbr title="\WooCommerceSubscriptionsAbstracts">WooCommerceSubscriptionsAbstracts</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsIncludes.html"><abbr title="\WooCommerceSubscriptionsIncludes">WooCommerceSubscriptionsIncludes</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceClassesEmails.html"><abbr title="\WooCommerceClassesEmails">WooCommerceClassesEmails</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/SkyVergeWooCommerceAPI.html"><abbr title="\SkyVergeWooCommerceAPI">SkyVergeWooCommerceAPI</abbr></a></h3>
                        </section>
    
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Reports</h2>
                <h3 class="phpdocumentor-sidebar__root-package"><a href="../reports/deprecated.html">Deprecated</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../reports/errors.html">Errors</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../reports/markers.html">Markers</a></h3>
    </section>

    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Indices</h2>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../indices/files.html">Files</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../hooks/hooks.html">Hooks Reference</a></h3>
    </section>
</aside>

            <div class="phpdocumentor-column -eight phpdocumentor-content">
                    <ul class="phpdocumentor-breadcrumbs">
            <li class="phpdocumentor-breadcrumb"><a href="../packages/WooCommerce.html">WooCommerce</a></li>
    </ul>

    <article class="phpdocumentor-element -file">
        <h2 class="phpdocumentor-content__title">class-wc-subscriptions-upgrader.php</h2>

                

        
                    <h3 class="phpdocumentor-elements__header" id="source-code">
                Source code
                <a href="#source-code" class="headerlink"><i class="fas fa-link"></i></a>
            </h3>
            <pre id="source-view" tabindex="-1" class="language-php line-numbers linkable-line-numbers"><code>&lt;?php
/**
 * A timeout resistant, single-serve upgrader for WC Subscriptions.
 *
 * This class is used to make all reasonable attempts to neatly upgrade data between versions of Subscriptions.
 *
 * For example, the way subscription data is stored changed significantly between v1.n and v2.0. It was imperative
 * the data be upgraded to the new schema without hassle. A hassle could easily occur if 100,000 orders were being
 * modified - memory exhaustion, script time out etc.
 *
 * @author      Prospress
 * @category    Admin
 * @package     WooCommerce Subscriptions/Admin/Upgrades
 * @version     2.0.0
 * @since       1.2
 */
class WC_Subscriptions_Upgrader {

	private static $active_version;

	private static $upgrade_limit_hooks;

	private static $upgrade_limit_subscriptions;

	private static $about_page_url;

	private static $old_subscription_count = null;

	public static $is_wc_version_2 = false;

	public static $updated_to_wc_2_0;

	/**
	 * @var array An array of WCS_Background_Updater objects used to run upgrade scripts in the background.
	 */
	protected static $background_updaters = array();

	/**
	 * Hooks upgrade function to init.
	 *
	 * @since 1.2
	 */
	public static function init() {

		self::$active_version = get_option( WC_Subscriptions_Admin::$option_prefix . &#039;_active_version&#039;, &#039;0&#039; );

		self::$is_wc_version_2 = version_compare( get_option( &#039;woocommerce_db_version&#039; ), &#039;2.0&#039;, &#039;&gt;=&#039; );

		self::$about_page_url = admin_url( &#039;admin.php?page=wc-admin&#039; );

		$version_out_of_date = version_compare( self::$active_version,  WC_Subscriptions_Core_Plugin::instance()-&gt;get_plugin_version(), &#039;&lt;&#039; );

		// Set the cron lock on every request with an out of date version, regardless of authentication level, as we can only lock cron for up to 10 minutes at a time, but we need to keep it locked until the upgrade is complete, regardless of who is browing the site
		if ( $version_out_of_date ) {
			self::set_cron_lock();
		}

		if ( isset( $_POST[&#039;action&#039;] ) &amp;&amp; &#039;wcs_upgrade&#039; == $_POST[&#039;action&#039;] ) { // We&#039;re checking for CSRF in ajax_upgrade

			add_action( &#039;wp_ajax_wcs_upgrade&#039;, __CLASS__ . &#039;::ajax_upgrade&#039;, 10 );

		} elseif ( @current_user_can( &#039;activate_plugins&#039; ) ) {

			if ( isset( $_GET[&#039;wcs_upgrade_step&#039;] ) || $version_out_of_date ) {

				$is_upgrading = get_option( &#039;wc_subscriptions_is_upgrading&#039;, false );

				// Check if we&#039;ve exceeded the 2 minute upgrade window we use for blocking upgrades (we could seemingly use transients here to get the check for free if transients were guaranteed to exist: http://journal.rmccue.io/296/youre-using-transients-wrong/)
				if ( false !== $is_upgrading &amp;&amp; $is_upgrading &lt; gmdate( &#039;U&#039; ) ) {
					$is_upgrading = false;
					delete_option( &#039;wc_subscriptions_is_upgrading&#039; );
				}

				if ( false !== $is_upgrading ) {

					add_action( &#039;init&#039;, __CLASS__ . &#039;::upgrade_in_progress_notice&#039;, 11 );

				} else {

					// Run upgrades as soon as admin hits site
					add_action( &#039;wp_loaded&#039;, __CLASS__ . &#039;::upgrade&#039;, 11 );

				}
			} elseif ( is_admin() &amp;&amp; isset( $_GET[&#039;page&#039;] ) &amp;&amp; &#039;wcs-about&#039; == $_GET[&#039;page&#039;] ) {

				add_action( &#039;admin_menu&#039;, __CLASS__ . &#039;::updated_welcome_page&#039; );

			}
		}

		// While the upgrade is in progress, we need to block PayPal IPN messages to avoid renewals failing to process
		add_action( &#039;woocommerce_api_wc_gateway_paypal&#039;, __CLASS__ . &#039;::maybe_block_paypal_ipn&#039;, 0 );

		// Sometimes redirect to the Welcome/About page after an upgrade
		add_action( &#039;woocommerce_subscriptions_upgraded&#039;, __CLASS__ . &#039;::maybe_redirect_after_upgrade_complete&#039;, 100, 2 );

		add_action( &#039;wcs_repair_end_of_prepaid_term_actions&#039;, __CLASS__ . &#039;::repair_end_of_prepaid_term_actions&#039; );

		add_action( &#039;wcs_repair_subscriptions_containing_synced_variations&#039;, __CLASS__ . &#039;::repair_subscription_contains_sync_meta&#039; );

		// When WC is updated from a version prior to 3.0 to a version after 3.0, add subscription address indexes. Must be hooked on before WC runs its updates, which occur on priority 5.
		add_action( &#039;init&#039;, array( __CLASS__, &#039;maybe_add_subscription_address_indexes&#039; ), 2 );

		add_action( &#039;admin_notices&#039;, array( __CLASS__, &#039;maybe_display_external_object_cache_warning&#039; ) );

		add_action( &#039;init&#039;, array( __CLASS__, &#039;initialise_background_updaters&#039; ), 0 );
	}

	/**
	 * Set limits on the number of items to upgrade at any one time based on the size of the site.
	 *
	 * The size of subscription at the time the upgrade is started is used to determine the batch size.
	 *
	 * @since 2.0
	 */
	protected static function set_upgrade_limits() {

		$total_initial_subscription_count = self::get_total_subscription_count( true );

		if ( $total_initial_subscription_count &gt; 5000 ) {
			$base_upgrade_limit = 20;
		} elseif ( $total_initial_subscription_count &gt; 1500 ) {
			$base_upgrade_limit = 30;
		} else {
			$base_upgrade_limit = 50;
		}

		self::$upgrade_limit_hooks         = apply_filters( &#039;woocommerce_subscriptions_hooks_to_upgrade&#039;, $base_upgrade_limit * 5 );
		self::$upgrade_limit_subscriptions = apply_filters( &#039;woocommerce_subscriptions_to_upgrade&#039;, $base_upgrade_limit );
	}

	/**
	 * Try to block WP-Cron until upgrading finishes. spawn_cron() will only let us steal the lock for 10 minutes into the future, so
	 * we can actually only block it for 9 minutes confidently. But as long as the upgrade process continues, the lock will remain.
	 *
	 * @since 2.0
	 */
	protected static function set_cron_lock() {
		delete_transient( &#039;doing_cron&#039; );
		set_transient( &#039;doing_cron&#039;, sprintf( &#039;%.22F&#039;, 9 * MINUTE_IN_SECONDS + microtime( true ) ), 0 );
	}

	/**
	 * Checks which upgrades need to run and calls the necessary functions for that upgrade.
	 *
	 * @since 1.2
	 */
	public static function upgrade() {
		global $wpdb;

		self::set_upgrade_limits();

		update_option( WC_Subscriptions_Admin::$option_prefix . &#039;_previous_version&#039;, self::$active_version );

		/**
		 * before upgrade hook.
		 */
		do_action( &#039;woocommerce_subscriptions_before_upgrade&#039;,  WC_Subscriptions_Core_Plugin::instance()-&gt;get_plugin_version(), self::$active_version );

		// Update the hold stock notification to be one week (if it&#039;s still at the default 60 minutes) to prevent cancelling subscriptions using manual renewals and payment methods that can take more than 1 hour (i.e. PayPal eCheck)
		if ( &#039;0&#039; == self::$active_version || version_compare( self::$active_version, &#039;1.4&#039;, &#039;&lt;&#039; ) ) {

			$hold_stock_duration = get_option( &#039;woocommerce_hold_stock_minutes&#039; );

			if ( 60 == $hold_stock_duration ) {
				update_option( &#039;woocommerce_hold_stock_minutes&#039;, 60 * 24 * 7 );
			}

			// Allow products &amp; subscriptions to be purchased in the same transaction
			update_option( &#039;woocommerce_subscriptions_multiple_purchase&#039;, &#039;yes&#039; );

		}

		// Keep track of site url to prevent duplicate payments from staging sites, first added in 1.3.8 &amp; updated with 1.4.2 to work with WP Engine staging sites
		if ( &#039;0&#039; == self::$active_version || version_compare( self::$active_version, &#039;1.4.2&#039;, &#039;&lt;&#039; ) ) {
			WCS_Staging::set_duplicate_site_url_lock();
		}

		// Migrate products, WP-Cron hooks and subscriptions to the latest architecture, via Ajax
		if ( &#039;0&#039; != self::$active_version &amp;&amp; version_compare( self::$active_version, &#039;2.0&#039;, &#039;&lt;&#039; ) ) {
			// Delete old cron locks
			$deleted_rows = $wpdb-&gt;query( &quot;DELETE FROM {$wpdb-&gt;options} WHERE `option_name` LIKE &#039;wcs\_blocker\_%&#039;&quot; );

			WCS_Upgrade_Logger::add( sprintf( &#039;Deleted %d rows of &quot;wcs_blocker_&quot;&#039;, $deleted_rows ) );

			self::ajax_upgrade_handler();
		}

		// Repair incorrect dates set when upgrading with 2.0.0
		if ( version_compare( self::$active_version, &#039;2.0.0&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( self::$active_version, &#039;2.0.2&#039;, &#039;&lt;&#039; ) &amp;&amp; self::migrated_subscription_count() &gt; 0 ) {
			self::ajax_upgrade_handler();
		}

		if ( &#039;0&#039; != self::$active_version &amp;&amp; version_compare( self::$active_version, &#039;2.1.0&#039;, &#039;&lt;&#039; ) ) {

			// Delete cached subscription length ranges to force an update with 2.1
			WC_Subscriptions_Core_Plugin::instance()-&gt;cache-&gt;delete_cached( &#039;wcs-sub-ranges-&#039; . get_locale() );
			WCS_Upgrade_Logger::add( &#039;v2.1: Deleted cached subscription ranges.&#039; );
			WCS_Upgrade_2_1::set_cancelled_dates();

			// Schedule report cache updates in the hopes that the data is ready and waiting for the store owner the first time they visit the reports pages
			do_action( &#039;woocommerce_subscriptions_reports_schedule_cache_updates&#039; );
		}

		// Repair missing end_of_prepaid_term scheduled actions
		if ( version_compare( self::$active_version, &#039;2.2.0&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( self::$active_version, &#039;2.2.7&#039;, &#039;&lt;&#039; ) ) {
			WCS_Upgrade_2_2_7::schedule_end_of_prepaid_term_repair();
		}

		// Repair missing _contains_synced_subscription post meta
		if ( version_compare( get_option( &#039;woocommerce_db_version&#039; ), &#039;3.0&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( self::$active_version, &#039;2.2.0&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( self::$active_version, &#039;2.2.9&#039;, &#039;&lt;&#039; ) ) {
			WCS_Upgrade_2_2_9::schedule_repair();
		}

		// Repair subscriptions suspended via PayPal.
		if ( version_compare( self::$active_version, &#039;2.1.4&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( self::$active_version, &#039;2.3.0&#039;, &#039;&lt;&#039; ) ) {
			self::$background_updaters[&#039;2.3&#039;][&#039;suspended_paypal_repair&#039;]-&gt;schedule_repair();
		}

		// If the store is running WC 3.0, repair subscriptions with missing address indexes.
		if ( &#039;0&#039; !== self::$active_version &amp;&amp; version_compare( self::$active_version, &#039;2.3.0&#039;, &#039;&lt;&#039; ) &amp;&amp; version_compare( WC()-&gt;version, &#039;3.0&#039;, &#039;&gt;=&#039; ) ) {
			self::$background_updaters[&#039;2.3&#039;][&#039;address_indexes_repair&#039;]-&gt;schedule_repair();
		}

		if ( version_compare( self::$active_version, &#039;2.3.0&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( self::$active_version, &#039;2.3.3&#039;, &#039;&lt;&#039; ) &amp;&amp; wp_using_ext_object_cache() ) {
			$has_transient_cache = $wpdb-&gt;get_var( &quot;SELECT option_id FROM {$wpdb-&gt;prefix}options WHERE option_name LIKE &#039;_transient_wcs-related-orders-to%&#039; OR option_name LIKE &#039;_transient_wcs_user_subscriptions_%&#039; LIMIT 1;&quot; );

			if ( ! empty( $has_transient_cache ) ) {
				update_option( &#039;wcs_display_2_3_3_warning&#039;, &#039;yes&#039; );
			}
		}

		if ( version_compare( self::$active_version, &#039;2.4.0&#039;, &#039;&lt;&#039; ) ) {
			self::$background_updaters[&#039;2.4&#039;][&#039;start_date_metadata&#039;]-&gt;schedule_repair();
		}

		// Upon upgrading or installing 2.5.0 for the first time, enable or disable PayPal Standard for Subscriptions.
		if ( version_compare( self::$active_version, &#039;2.5.0&#039;, &#039;&lt;&#039; ) ) {
			WCS_PayPal::set_enabled_for_subscriptions_default();
		}

		// Upon upgrading to 2.6.0 from a version after 2.2.0, schedule missing _has_trial line item meta repair.
		if ( version_compare( self::$active_version, &#039;2.6.0&#039;, &#039;&lt;&#039; ) &amp;&amp; version_compare( self::$active_version, &#039;2.2.0&#039;, &#039;&gt;=&#039; ) ) {
			self::$background_updaters[&#039;2.6&#039;][&#039;has_trial_item_meta&#039;]-&gt;schedule_repair();
		}

		// Delete old subscription period string ranges transients.
		if ( version_compare( self::$active_version, &#039;3.0.10&#039;, &#039;&lt;&#039; ) ) {
			$deleted_rows = $wpdb-&gt;query( &quot;DELETE FROM {$wpdb-&gt;options} WHERE `option_name` LIKE &#039;_transient_timeout_wcs-sub-ranges-%&#039; OR `option_name` LIKE &#039;_transient_wcs-sub-ranges-%&#039;&quot; );
		}

		// When upgrading from version 3.0.12, delete `switch_totals_calc_base_length` meta from product post meta as it was saved rather than set in memory.
		if ( version_compare( self::$active_version, &#039;3.0.12&#039;, &#039;==&#039; ) ) {
			$deleted_rows = $wpdb-&gt;query( &quot;DELETE FROM {$wpdb-&gt;postmeta} WHERE `meta_key` = &#039;_switch_totals_calc_base_length&#039;&quot; );
		}

		if ( version_compare( self::$active_version, &#039;3.1.0&#039;, &#039;&lt;&#039; ) ) {
			// Upon upgrading to 3.1.0 from a version after 3.0.10, repair subscriptions _subtracted_base_location_tax line item meta.
			if ( version_compare( self::$active_version, &#039;3.0.10&#039;, &#039;&gt;=&#039; ) ) {
				self::$background_updaters[&#039;3.1&#039;][&#039;subtracted_base_tax_repair&#039;]-&gt;schedule_repair();
			}

			WCS_Upgrade_3_1_0::migrate_subscription_webhooks_using_api_version_3();
		}

		self::upgrade_complete();
	}

	/**
	 * When an upgrade is complete, set the active version, delete the transient locking upgrade and fire a hook.
	 *
	 * @since 1.2
	 */
	public static function upgrade_complete() {

		update_option( WC_Subscriptions_Admin::$option_prefix . &#039;_active_version&#039;,  WC_Subscriptions_Core_Plugin::instance()-&gt;get_plugin_version() );

		delete_transient( &#039;doing_cron&#039; );

		delete_option( &#039;wc_subscriptions_is_upgrading&#039; );

		do_action( &#039;woocommerce_subscriptions_upgraded&#039;,  WC_Subscriptions_Core_Plugin::instance()-&gt;get_plugin_version(), self::$active_version );
	}

	/**
	 * Redirect to the Subscriptions major version Welcome/About page for major version updates
	 *
	 * @since 2.1
	 */
	public static function maybe_redirect_after_upgrade_complete( $current_version, $previously_active_version ) {
		if ( version_compare( $previously_active_version, &#039;2.1.0&#039;, &#039;&lt;&#039; ) &amp;&amp; version_compare( $current_version, &#039;2.1.0&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( $current_version, &#039;2.2.0&#039;, &#039;&lt;&#039; ) ) {
			wp_safe_redirect( self::$about_page_url );
			exit();
		}
	}

	/**
	 * Add support for quantities for subscriptions.
	 * Update all current subscription wp_cron tasks to the new action-scheduler system.
	 *
	 * @since 2.0
	 */
	private static function ajax_upgrade_handler() {

		$_GET[&#039;wcs_upgrade_step&#039;] = ( ! isset( $_GET[&#039;wcs_upgrade_step&#039;] ) ) ? 0 : $_GET[&#039;wcs_upgrade_step&#039;];

		switch ( (int) $_GET[&#039;wcs_upgrade_step&#039;] ) {
			case 1:
				self::display_database_upgrade_helper();
				break;
			case 3: // keep a way to circumvent the upgrade routine just in case
				self::upgrade_complete();
				wp_safe_redirect( self::$about_page_url );
				break;
			case 0:
			default:
				wp_safe_redirect( admin_url( &#039;admin.php?wcs_upgrade_step=1&#039; ) );
				break;
		}

		exit();
	}

	/**
	 * Move scheduled subscription hooks out of wp-cron and into the new Action Scheduler.
	 *
	 * Also set all existing subscriptions to &quot;sold individually&quot; to maintain previous behavior
	 * for existing subscription products before the subscription quantities feature was enabled..
	 *
	 * @since 1.5
	 */
	public static function ajax_upgrade() {
		global $wpdb;

		check_admin_referer( &#039;wcs_upgrade_process&#039;, &#039;nonce&#039; );

		self::set_upgrade_limits();

		WCS_Upgrade_Logger::add( sprintf( &#039;Starting upgrade step: %s&#039;, $_POST[&#039;upgrade_step&#039;] ) );

		if ( ini_get( &#039;max_execution_time&#039; ) &lt; 600 ) {
			@set_time_limit( 600 );
		}

		@ini_set( &#039;memory_limit&#039;, apply_filters( &#039;admin_memory_limit&#039;, WP_MAX_MEMORY_LIMIT ) );

		update_option( &#039;wc_subscriptions_is_upgrading&#039;, gmdate( &#039;U&#039; ) + 60 * 2 );

		switch ( $_POST[&#039;upgrade_step&#039;] ) {

			case &#039;really_old_version&#039;:
				$upgraded_versions = self::upgrade_really_old_versions();
				$results = array(
					// translators: placeholder is a list of version numbers (e.g. &quot;1.3 &amp; 1.4 &amp; 1.5&quot;)
					&#039;message&#039; =&gt; sprintf( __( &#039;Database updated to version %s&#039;, &#039;woocommerce-subscriptions&#039; ), $upgraded_versions ),
				);
				break;

			case &#039;products&#039;:
				$upgraded_product_count = WCS_Upgrade_1_5::upgrade_products();
				$results = array(
					// translators: placeholder is number of upgraded subscriptions
					&#039;message&#039; =&gt; sprintf( _x( &#039;Marked %s subscription products as &quot;sold individually&quot;.&#039;, &#039;used in the subscriptions upgrader&#039;, &#039;woocommerce-subscriptions&#039; ), $upgraded_product_count ),
				);
				break;

			case &#039;hooks&#039;:
				$upgraded_hook_count = WCS_Upgrade_1_5::upgrade_hooks( self::$upgrade_limit_hooks );
				$results = array(
					&#039;upgraded_count&#039; =&gt; $upgraded_hook_count,
					// translators: 1$: number of action scheduler hooks upgraded, 2$: &quot;{execution_time}&quot;, will be replaced on front end with actual time
					&#039;message&#039;        =&gt; sprintf( __( &#039;Migrated %1$s subscription related hooks to the new scheduler (in %2$s seconds).&#039;, &#039;woocommerce-subscriptions&#039; ), $upgraded_hook_count, &#039;{execution_time}&#039; ),
				);
				break;

			case &#039;subscriptions&#039;:
				try {

					$upgraded_subscriptions = WCS_Upgrade_2_0::upgrade_subscriptions( self::$upgrade_limit_subscriptions );

					$results = array(
						&#039;upgraded_count&#039; =&gt; $upgraded_subscriptions,
						// translators: 1$: number of subscriptions upgraded, 2$: &quot;{execution_time}&quot;, will be replaced on front end with actual time it took
						&#039;message&#039;        =&gt; sprintf( __( &#039;Migrated %1$s subscriptions to the new structure (in %2$s seconds).&#039;, &#039;woocommerce-subscriptions&#039; ), $upgraded_subscriptions, &#039;{execution_time}&#039; ),
						&#039;status&#039;         =&gt; &#039;success&#039;,
						// translators: placeholder is &quot;{time_left}&quot;, will be replaced on front end with actual time
						&#039;time_message&#039;   =&gt; sprintf( _x( &#039;Estimated time left (minutes:seconds): %s&#039;, &#039;Message that gets sent to front end.&#039;, &#039;woocommerce-subscriptions&#039; ), &#039;{time_left}&#039; ),
					);

				} catch ( Exception $e ) {

					WCS_Upgrade_Logger::add( sprintf( &#039;Error on upgrade step: %s. Error: %s&#039;, $_POST[&#039;upgrade_step&#039;], $e-&gt;getMessage() ) );

					$results = array(
						&#039;upgraded_count&#039; =&gt; 0,
						// translators: 1$: error message, 2$: opening link tag, 3$: closing link tag, 4$: break tag
						&#039;message&#039;        =&gt; sprintf( __( &#039;Unable to upgrade subscriptions.%4$sError: %1$s%4$sPlease refresh the page and try again. If problem persists, %2$scontact support%3$s.&#039;, &#039;woocommerce-subscriptions&#039; ), &#039;&lt;code&gt;&#039; . $e-&gt;getMessage() . &#039;&lt;/code&gt;&#039;, &#039;&lt;a href=&quot;&#039; . esc_url( &#039;https://woocommerce.com/my-account/create-a-ticket/&#039; ) . &#039;&quot;&gt;&#039;, &#039;&lt;/a&gt;&#039;, &#039;&lt;br /&gt;&#039; ),
						&#039;status&#039;         =&gt; &#039;error&#039;,
					);
				}

				break;

			case &#039;subscription_dates_repair&#039;:
				$subscription_ids_to_repair = WCS_Repair_2_0_2::get_subscriptions_to_repair( self::$upgrade_limit_subscriptions );

				try {

					$subscription_counts = WCS_Repair_2_0_2::maybe_repair_subscriptions( $subscription_ids_to_repair );

					// translators: placeholder is the number of subscriptions repaired
					$repair_incorrect = sprintf( _x( &#039;Repaired %d subscriptions with incorrect dates, line tax data or missing customer notes.&#039;, &#039;Repair message that gets sent to front end.&#039;, &#039;woocommerce-subscriptions&#039; ), $subscription_counts[&#039;repaired_count&#039;] );

					$repair_not_needed = &#039;&#039;;

					if ( $subscription_counts[&#039;unrepaired_count&#039;] &gt; 0 ) {
						// translators: placeholder is number of subscriptions that were checked and did not need repairs. There&#039;s a space at the beginning!
						$repair_not_needed = sprintf( _nx( &#039; %d other subscription was checked and did not need any repairs.&#039;, &#039;%d other subscriptions were checked and did not need any repairs.&#039;, $subscription_counts[&#039;unrepaired_count&#039;], &#039;Repair message that gets sent to front end.&#039;, &#039;woocommerce-subscriptions&#039; ), $subscription_counts[&#039;unrepaired_count&#039;] );
					}

					// translators: placeholder is &quot;{execution_time}&quot;, which will be replaced on front end with actual time
					$repair_time = sprintf( _x( &#039;(in %s seconds)&#039;, &#039;Repair message that gets sent to front end.&#039;, &#039;woocommerce-subscriptions&#039; ), &#039;{execution_time}&#039; );

					// translators: $1: &quot;Repaired x subs with incorrect dates...&quot;, $2: &quot;X others were checked and no repair needed&quot;, $3: &quot;(in X seconds)&quot;. Ordering for RTL languages.
					$repair_message = sprintf( _x( &#039;%1$s%2$s %3$s&#039;, &#039;The assembled repair message that gets sent to front end.&#039;, &#039;woocommerce-subscriptions&#039; ), $repair_incorrect, $repair_not_needed, $repair_time );

					$results = array(
						&#039;repaired_count&#039;   =&gt; $subscription_counts[&#039;repaired_count&#039;],
						&#039;unrepaired_count&#039; =&gt; $subscription_counts[&#039;unrepaired_count&#039;],
						&#039;message&#039;          =&gt; $repair_message,
						&#039;status&#039;           =&gt; &#039;success&#039;,
						// translators: placeholder is &quot;{time_left}&quot;, will be replaced on front end with actual time
						&#039;time_message&#039;     =&gt; sprintf( _x( &#039;Estimated time left (minutes:seconds): %s&#039;, &#039;Message that gets sent to front end.&#039;, &#039;woocommerce-subscriptions&#039; ), &#039;{time_left}&#039; ),
					);

				} catch ( Exception $e ) {

					WCS_Upgrade_Logger::add( sprintf( &#039;Error on upgrade step: %s. Error: %s&#039;, $_POST[&#039;upgrade_step&#039;], $e-&gt;getMessage() ) );

					$results = array(
						&#039;repaired_count&#039;   =&gt; 0,
						&#039;unrepaired_count&#039; =&gt; 0,
						// translators: 1$: error message, 2$: opening link tag, 3$: closing link tag, 4$: break tag
						&#039;message&#039;          =&gt; sprintf( _x( &#039;Unable to repair subscriptions.%4$sError: %1$s%4$sPlease refresh the page and try again. If problem persists, %2$scontact support%3$s.&#039;, &#039;Error message that gets sent to front end when upgrading Subscriptions&#039;, &#039;woocommerce-subscriptions&#039; ), &#039;&lt;code&gt;&#039; . $e-&gt;getMessage() . &#039;&lt;/code&gt;&#039;, &#039;&lt;a href=&quot;&#039; . esc_url( &#039;https://woocommerce.com/my-account/create-a-ticket/&#039; ) . &#039;&quot;&gt;&#039;, &#039;&lt;/a&gt;&#039;, &#039;&lt;br /&gt;&#039; ),
						&#039;status&#039;           =&gt; &#039;error&#039;,
					);
				}

				break;
		}

		if ( &#039;subscriptions&#039; == $_POST[&#039;upgrade_step&#039;] &amp;&amp; 0 === self::get_total_subscription_count_query() ) {

			self::upgrade_complete();

		} elseif ( &#039;subscription_dates_repair&#039; == $_POST[&#039;upgrade_step&#039;] ) {

			$subscriptions_to_repair = WCS_Repair_2_0_2::get_subscriptions_to_repair( self::$upgrade_limit_subscriptions );

			if ( empty( $subscriptions_to_repair ) ) {
				self::upgrade_complete();
			}
		}

		WCS_Upgrade_Logger::add( sprintf( &#039;Completed upgrade step: %s&#039;, $_POST[&#039;upgrade_step&#039;] ) );

		header( &#039;Content-Type: application/json; charset=utf-8&#039; );
		echo wcs_json_encode( $results );
		exit();
	}

	/**
	 * Handle upgrades for really old versions.
	 *
	 * @since 2.0
	 */
	private static function upgrade_really_old_versions() {

		if ( &#039;0&#039; != self::$active_version &amp;&amp; version_compare( self::$active_version, &#039;1.2&#039;, &#039;&lt;&#039; ) ) {
			WCS_Upgrade_1_2::init();
			self::generate_renewal_orders();
			update_option( WC_Subscriptions_Admin::$option_prefix . &#039;_active_version&#039;, &#039;1.2&#039; );
			$upgraded_versions = &#039;1.2, &#039;;
		}

		// Add Variable Subscription product type term
		if ( &#039;0&#039; != self::$active_version &amp;&amp; version_compare( self::$active_version, &#039;1.3&#039;, &#039;&lt;&#039; ) ) {
			WCS_Upgrade_1_3::init();
			update_option( WC_Subscriptions_Admin::$option_prefix . &#039;_active_version&#039;, &#039;1.3&#039; );
			$upgraded_versions .= &#039;1.3 &amp; &#039;;
		}

		// Moving subscription meta out of user meta and into item meta
		if ( &#039;0&#039; != self::$active_version &amp;&amp; version_compare( self::$active_version, &#039;1.4&#039;, &#039;&lt;&#039; ) ) {
			WCS_Upgrade_1_4::init();
			update_option( WC_Subscriptions_Admin::$option_prefix . &#039;_active_version&#039;, &#039;1.4&#039; );
			$upgraded_versions .= &#039;1.4.&#039;;
		}

		return $upgraded_versions;
	}

	/**
	 * Version 1.2 introduced child renewal orders to keep a record of each completed subscription
	 * payment. Before 1.2, these orders did not exist, so this function creates them.
	 *
	 * @since 1.2
	 */
	private static function generate_renewal_orders() {
		global $wpdb;
		$woocommerce = WC();

		$subscriptions_grouped_by_user = WC_Subscriptions_Manager::get_all_users_subscriptions();

		// Don&#039;t send any order emails
		$email_actions = array( &#039;woocommerce_low_stock&#039;, &#039;woocommerce_no_stock&#039;, &#039;woocommerce_product_on_backorder&#039;, &#039;woocommerce_order_status_pending_to_processing&#039;, &#039;woocommerce_order_status_pending_to_completed&#039;, &#039;woocommerce_order_status_pending_to_on-hold&#039;, &#039;woocommerce_order_status_failed_to_processing&#039;, &#039;woocommerce_order_status_failed_to_completed&#039;, &#039;woocommerce_order_status_pending_to_processing&#039;, &#039;woocommerce_order_status_pending_to_on-hold&#039;, &#039;woocommerce_order_status_completed&#039;, &#039;woocommerce_new_customer_note&#039; );
		foreach ( $email_actions as $action ) {
			remove_action( $action, array( &amp;$woocommerce, &#039;send_transactional_email&#039; ) );
		}

		remove_action( &#039;woocommerce_payment_complete&#039;, &#039;WC_Subscriptions_Renewal_Order::maybe_record_renewal_order_payment&#039;, 10, 1 );

		foreach ( $subscriptions_grouped_by_user as $user_id =&gt; $users_subscriptions ) {
			foreach ( $users_subscriptions as $subscription_key =&gt; $subscription ) {
				$order_post = get_post( $subscription[&#039;order_id&#039;] );

				if ( isset( $subscription[&#039;completed_payments&#039;] ) &amp;&amp; count( $subscription[&#039;completed_payments&#039;] ) &gt; 0 &amp;&amp; null != $order_post ) {
					foreach ( $subscription[&#039;completed_payments&#039;] as $payment_date ) {

						$existing_renewal_order = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT ID FROM {$wpdb-&gt;posts} WHERE post_date_gmt = %s AND post_parent = %d AND post_type = &#039;shop_order&#039;&quot;, $payment_date, $subscription[&#039;order_id&#039;] ) );

						// If a renewal order exists on this date, don&#039;t generate another one
						if ( null !== $existing_renewal_order ) {
							continue;
						}

						$renewal_order_id = WC_Subscriptions_Renewal_Order::generate_renewal_order( $subscription[&#039;order_id&#039;], $subscription[&#039;product_id&#039;], array( &#039;new_order_role&#039; =&gt; &#039;child&#039; ) );

						if ( $renewal_order_id ) {

							// Mark the order as paid
							$renewal_order = wc_get_order( $renewal_order_id );

							$renewal_order-&gt;payment_complete();

							// Avoid creating 100s &quot;processing&quot; orders
							$renewal_order-&gt;update_status( &#039;completed&#039; );

							// Set correct dates on the order
							$renewal_order = array(
								&#039;ID&#039;            =&gt; $renewal_order_id,
								&#039;post_date&#039;     =&gt; $payment_date,
								&#039;post_date_gmt&#039; =&gt; $payment_date,
							);
							wp_update_post( $renewal_order );

							update_post_meta( $renewal_order_id, &#039;_paid_date&#039;, $payment_date );
							update_post_meta( $renewal_order_id, &#039;_completed_date&#039;, $payment_date );

						}
					}
				}
			}
		}
	}

	/**
	 * Let the site administrator know we are upgrading the database and provide a confirmation is complete.
	 *
	 * This is important to avoid the possibility of a database not upgrading correctly, but the site continuing
	 * to function without any remedy.
	 *
	 * @since 1.2
	 */
	public static function display_database_upgrade_helper() {

		wp_register_style( &#039;wcs-upgrade&#039;, WC_Subscriptions_Core_Plugin::instance()-&gt;get_subscriptions_core_directory_url( &#039;assets/css/wcs-upgrade.css&#039; ) );
		wp_register_script( &#039;wcs-upgrade&#039;, WC_Subscriptions_Core_Plugin::instance()-&gt;get_subscriptions_core_directory_url( &#039;assets/js/wcs-upgrade.js&#039; ), &#039;jquery&#039; );

		if ( version_compare( self::$active_version, &#039;2.0.0&#039;, &#039;&lt;&#039; ) ) {
			// We&#039;re running the 2.0 upgrade routine
			$subscription_count = self::get_total_subscription_count();
		} elseif ( version_compare( self::$active_version, &#039;2.0.0&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( self::$active_version, &#039;2.0.2&#039;, &#039;&lt;&#039; ) ) {
			// We&#039;re running the 2.0.2 repair routine
			$subscription_counts = wp_count_posts( &#039;shop_subscription&#039; );
			$subscription_count  = array_sum( (array) $subscription_counts ) - $subscription_counts-&gt;trash - $subscription_counts-&gt;{&#039;auto-draft&#039;};
		} else {
			// How did we get here?
			$subscription_count = 0;
		}

		$script_data = array(
			&#039;really_old_version&#039; =&gt; ( version_compare( self::$active_version, &#039;1.4&#039;, &#039;&lt;&#039; ) ) ? &#039;true&#039; : &#039;false&#039;,
			&#039;upgrade_to_1_5&#039;     =&gt; ( version_compare( self::$active_version, &#039;1.5&#039;, &#039;&lt;&#039; ) ) ? &#039;true&#039; : &#039;false&#039;,
			&#039;upgrade_to_2_0&#039;     =&gt; ( version_compare( self::$active_version, &#039;2.0.0&#039;, &#039;&lt;&#039; ) ) ? &#039;true&#039; : &#039;false&#039;,
			&#039;repair_2_0&#039;         =&gt; ( version_compare( self::$active_version, &#039;2.0.0&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( self::$active_version, &#039;2.0.2&#039;, &#039;&lt;&#039; ) ) ? &#039;true&#039; : &#039;false&#039;,
			&#039;hooks_per_request&#039;  =&gt; self::$upgrade_limit_hooks,
			&#039;ajax_url&#039;           =&gt; admin_url( &#039;admin-ajax.php&#039; ),
			&#039;upgrade_nonce&#039;      =&gt; wp_create_nonce( &#039;wcs_upgrade_process&#039; ),
			&#039;subscription_count&#039; =&gt; $subscription_count,
		);

		wp_localize_script( &#039;wcs-upgrade&#039;, &#039;wcs_update_script_data&#039;, $script_data );

		// Can&#039;t get subscription count with database structure &lt; 1.4
		if ( &#039;false&#039; == $script_data[&#039;really_old_version&#039;] ) {

			// The base duration is 50 subscriptions per minute (i.e. approximately 60 seconds per batch of 50)
			$estimated_duration = ceil( $subscription_count / 50 );

			// Large sites take about 2-3x as long (i.e. approximately 80 seconds per batch of 35)
			if ( $subscription_count &gt; 5000 ) {
				$estimated_duration *= 3;
			}

			// And really large sites take around 5-6x as long (i.e. approximately 100 seconds per batch of 25)
			if ( $subscription_count &gt; 10000 ) {
				$estimated_duration *= 2;
			}
		}

		$about_page_url = self::$about_page_url;

		@header( &#039;Content-Type: &#039; . get_option( &#039;html_type&#039; ) . &#039;; charset=&#039; . get_option( &#039;blog_charset&#039; ) );
		include_once( dirname( __FILE__ ) . &#039;/templates/wcs-upgrade.php&#039; );
		WCS_Upgrade_Logger::add( &#039;Loaded database upgrade helper&#039; );
	}

	/**
	 * Let the site administrator know we are upgrading the database already to prevent duplicate processes running the
	 * upgrade. Also provides some useful diagnostic information, like how long before the site admin can restart the
	 * upgrade process, and how many subscriptions per request can typically be updated given the amount of memory
	 * allocated to PHP.
	 *
	 * @since 1.4
	 */
	public static function upgrade_in_progress_notice() {
		include_once( dirname( __FILE__ ) . &#039;/templates/wcs-upgrade-in-progress.php&#039; );
		WCS_Upgrade_Logger::add( &#039;Loaded database upgrade in progress notice...&#039; );
	}

	/**
	 * Display the Subscriptions welcome/about page after successfully upgrading to the latest version.
	 *
	 * @since 1.4
	 */
	public static function updated_welcome_page() {
		$about_page = add_dashboard_page( __( &#039;Welcome to WooCommerce Subscriptions 2.1&#039;, &#039;woocommerce-subscriptions&#039; ), __( &#039;About WooCommerce Subscriptions&#039;, &#039;woocommerce-subscriptions&#039; ), &#039;manage_options&#039;, &#039;wcs-about&#039;, __CLASS__ . &#039;::about_screen&#039; );
		add_action( &#039;admin_print_styles-&#039; . $about_page, __CLASS__ . &#039;::admin_css&#039; );
		add_action( &#039;admin_head&#039;, __CLASS__ . &#039;::admin_head&#039; );
	}

	/**
	 * admin_css function.
	 *
	 * @access public
	 * @return void
	 */
	public static function admin_css() {
		wp_enqueue_style( &#039;woocommerce-subscriptions-about&#039;, WC_Subscriptions_Core_Plugin::instance()-&gt;get_subscriptions_core_directory_url( &#039;assets/css/about.css&#039; ), array(), self::$active_version );
	}

	/**
	 * Add styles just for this page, and remove dashboard page links.
	 *
	 * @access public
	 * @return void
	 */
	public static function admin_head() {
		remove_submenu_page( &#039;index.php&#039;, &#039;wcs-about&#039; );
	}

	/**
	 * Output the about screen.
	 */
	public static function about_screen() {

		$active_version = self::$active_version;
		$settings_page  = admin_url( &#039;admin.php?page=wc-settings&amp;tab=subscriptions&#039; );

		include_once( dirname( __FILE__ ) . &#039;/templates/wcs-about.php&#039; );
	}

	/**
	 * In v2.0 and newer, it&#039;s possible to simply use wp_count_posts( &#039;shop_subscription&#039; ) to count subscriptions,
	 * but not in v1.5, because a subscription data is still stored in order item meta. This function queries the
	 * v1.5 database structure.
	 *
	 * @since 2.0
	 */
	private static function get_total_subscription_count( $initial = false ) {

		if ( $initial ) {

			$subscription_count = get_option( &#039;wcs_upgrade_initial_total_subscription_count&#039;, false );

			if ( false === $subscription_count ) {
				$subscription_count = self::get_total_subscription_count();
				update_option( &#039;wcs_upgrade_initial_total_subscription_count&#039;, $subscription_count );
			}
		} else {

			if ( null === self::$old_subscription_count ) {
				self::$old_subscription_count = self::get_total_subscription_count_query();
			}

			$subscription_count = self::$old_subscription_count;
		}

		return $subscription_count;
	}

	/**
	 * Returns the number of subscriptions left in the 1.5 structure
	 * @return integer number of 1.5 subscriptions left
	 */
	private static function get_total_subscription_count_query() {
		global $wpdb;

		$query = self::get_subscription_query();

		$wpdb-&gt;get_results( $query );

		return $wpdb-&gt;num_rows;
	}

	/**
	 * Single source of truth for the query
	 * @param  integer $limit the number of subscriptions to get
	 * @return string        SQL query of what we need
	 */
	public static function get_subscription_query( $batch_size = null ) {
		global $wpdb;

		if ( null === $batch_size ) {
			$select = &#039;SELECT DISTINCT items.order_item_id&#039;;
			$limit = &#039;&#039;;
		} else {
			$select = &#039;SELECT meta.*, items.*&#039;;
			$limit = sprintf( &#039; LIMIT 0, %d&#039;, $batch_size );
		}

		$query = sprintf( &quot;%s FROM `{$wpdb-&gt;prefix}woocommerce_order_itemmeta` AS meta
			LEFT JOIN `{$wpdb-&gt;prefix}woocommerce_order_items` AS items USING (order_item_id)
			LEFT JOIN (
				SELECT a.order_item_id FROM `{$wpdb-&gt;prefix}woocommerce_order_itemmeta` AS a
				LEFT JOIN (
					SELECT `{$wpdb-&gt;prefix}woocommerce_order_itemmeta`.order_item_id FROM `{$wpdb-&gt;prefix}woocommerce_order_itemmeta`
					WHERE `{$wpdb-&gt;prefix}woocommerce_order_itemmeta`.meta_key = &#039;_subscription_status&#039;
				) AS s
				USING (order_item_id)
				WHERE 1=1
				AND a.order_item_id = s.order_item_id
				AND a.meta_key = &#039;_subscription_start_date&#039;
				ORDER BY CASE WHEN CAST(a.meta_value AS DATETIME) IS NULL THEN 1 ELSE 0 END, CAST(a.meta_value AS DATETIME) ASC
				%s
			) AS a3 USING (order_item_id)
			WHERE meta.meta_key REGEXP &#039;_subscription_(.*)|_product_id|_variation_id&#039;
			AND meta.order_item_id = a3.order_item_id
			AND items.order_item_id IS NOT NULL&quot;, $select, $limit );

		return $query;
	}

	/**
	 * Check if the database has some data that was migrated from 1.5 to 2.0
	 *
	 * @return bool True if it detects some v1.5 migrated data, otherwise false
	 */
	protected static function migrated_subscription_count() {
		global $wpdb;

		$migrated_subscription_count = $wpdb-&gt;get_var(
			&quot;SELECT COUNT(DISTINCT `post_id`) FROM $wpdb-&gt;postmeta
			 WHERE `meta_key` LIKE &#039;%wcs\_migrated%&#039;&quot;
		);

		return $migrated_subscription_count;
	}

	/**
	 * While the upgrade is in progress, we need to block IPN messages to avoid renewals failing to process correctly.
	 *
	 * PayPal will retry the IPNs for up to a day or two until it has a successful request, so the store will continue to receive
	 * IPN messages during the upgrade process, then once it is completed, the IPN will be successfully processed.
	 *
	 * The method returns a 409 Conflict HTTP response code to indicate that the IPN is conflicting with the upgrader.
	 *
	 * @since 2.0
	 */
	public static function maybe_block_paypal_ipn() {
		if ( false !== get_option( &#039;wc_subscriptions_is_upgrading&#039;, false ) ) {
			WCS_Upgrade_Logger::add( &#039;*** PayPal IPN Request blocked: &#039; . print_r( wp_unslash( $_POST ), true ) ); // No CSRF needed as it&#039;s from outside
			wp_die( &#039;PayPal IPN Request Failure&#039;, &#039;PayPal IPN&#039;, array( &#039;response&#039; =&gt; 409 ) );
		}
	}

	/**
	 * Run the end of prepaid term repair script.
	 *
	 * @since 2.2.7
	 */
	public static function repair_end_of_prepaid_term_actions() {
		WCS_Upgrade_2_2_7::repair_pending_cancelled_subscriptions();
	}

	/**
	 * Repair subscriptions with missing contains_synced_subscription post meta.
	 *
	 * @since 2.2.9
	 */
	public static function repair_subscription_contains_sync_meta() {
		WCS_Upgrade_2_2_9::repair_subscriptions_containing_synced_variations();
	}

	/**
	 * When updating WC to a version after 3.0 from a version prior to 3.0, schedule the repair script to add address indexes.
	 *
	 * @since 2.3.0
	 */
	public static function maybe_add_subscription_address_indexes() {
		$woocommerce_active_version   = WC()-&gt;version;
		$woocommerce_database_version = get_option( &#039;woocommerce_version&#039; );

		if ( $woocommerce_active_version !== $woocommerce_database_version &amp;&amp; version_compare( $woocommerce_active_version, &#039;3.0&#039;, &#039;&gt;=&#039; ) &amp;&amp; version_compare( $woocommerce_database_version, &#039;3.0&#039;, &#039;&lt;&#039; ) ) {
			self::$background_updaters[&#039;2.3&#039;][&#039;address_indexes_repair&#039;]-&gt;schedule_repair();
		}
	}

	/**
	 * Load and initialise the background updaters.
	 *
	 * @since 2.4.0
	 */
	public static function initialise_background_updaters() {
		$logger = new WC_logger();
		self::$background_updaters[&#039;2.3&#039;][&#039;suspended_paypal_repair&#039;]    = new WCS_Repair_Suspended_PayPal_Subscriptions( $logger );
		self::$background_updaters[&#039;2.3&#039;][&#039;address_indexes_repair&#039;]     = new WCS_Repair_Subscription_Address_Indexes( $logger );
		self::$background_updaters[&#039;2.4&#039;][&#039;start_date_metadata&#039;]        = new WCS_Repair_Start_Date_Metadata( $logger );
		self::$background_updaters[&#039;2.6&#039;][&#039;has_trial_item_meta&#039;]        = new WCS_Repair_Line_Item_Has_Trial_Meta( $logger );
		self::$background_updaters[&#039;3.1&#039;][&#039;subtracted_base_tax_repair&#039;] = new WCS_Repair_Subtracted_Base_Tax_Line_Item_Meta( $logger );

		// Init the updaters
		foreach ( self::$background_updaters as $version =&gt; $updaters ) {
			foreach ( $updaters as $updater ) {
				$updater-&gt;init();
			}
		}
	}

	/**
	 * Display an admin notice if the site had customer subscription and/or subscription renewal order cached data stored in the options table
	 * and was using an external object cache at the time of updating to 2.3.3.
	 *
	 * Under these circumstances, there is a chance that the persistent caches introduced in 2.3 could contain invalid data.
	 *
	 * @see https://github.com/Prospress/woocommerce-subscriptions/issues/2822 for more details.
	 * @since 2.3.3
	 */
	public static function maybe_display_external_object_cache_warning() {
		$option_name = &#039;wcs_display_2_3_3_warning&#039;;
		$nonce       = &#039;_wcsnonce&#039;;
		$action      = &#039;wcs_external_cache_warning&#039;;

		// First, check if the notice is being dismissed.
		if ( isset( $_GET[ $action ], $_GET[ $nonce ] ) &amp;&amp; wp_verify_nonce( $_GET[ $nonce ], $action ) ) {
			delete_option( $option_name );
			return;
		}

		if ( &#039;yes&#039; !== get_option( $option_name ) ) {
			return;
		}

		$admin_notice = new WCS_Admin_Notice( &#039;error&#039; );
		$admin_notice-&gt;set_simple_content(
			sprintf(
				// translators: 1-2: opening/closing &lt;strong&gt; tags, 3-4: opening/closing tags linked to ticket form.
				esc_html__( &#039;%1$sWarning!%2$s We discovered an issue in %1$sWooCommerce Subscriptions 2.3.0 - 2.3.2%2$s that may cause your subscription renewal order and customer subscription caches to contain invalid data. For information about how to update the cached data, please %3$sopen a new support ticket%4$s.&#039;, &#039;woocommerce-subscriptions&#039; ),
				&#039;&lt;strong&gt;&#039;, &#039;&lt;/strong&gt;&#039;,
				&#039;&lt;a href=&quot;https://woocommerce.com/my-account/marketplace-ticket-form/&quot; target=&quot;_blank&quot;&gt;&#039;, &#039;&lt;/a&gt;&#039;
			)
		);
		$admin_notice-&gt;set_actions( array(
			array(
				&#039;name&#039; =&gt; &#039;Dismiss&#039;,
				&#039;url&#039;  =&gt; wp_nonce_url( add_query_arg( $action, &#039;dismiss&#039; ), $action, $nonce ),
			),
		) );

		$admin_notice-&gt;display();
	}

	/**
	 * Repair a single item&#039;s subtracted base tax meta.
	 *
	 * @since 3.1.0
	 * @param int $item_id The ID of the item which needs repairing.
	 */
	public static function repair_subtracted_base_taxes( $item_id ) {
		self::$background_updaters[&#039;3.1&#039;][&#039;subtracted_base_tax_repair&#039;]-&gt;repair_item( $item_id );
	}

	/* Deprecated Functions */

	/**
	 * Handles the WC 3.5.0 upgrade routine that moves customer IDs from post metadata to the &#039;post_author&#039; column.
	 *
	 * @since 2.4.0
	 * @deprecated 2.5.0
	 */
	public static function maybe_update_subscription_post_author() {
		wcs_deprecated_function( __METHOD__, &#039;2.5.0&#039; );

		if ( version_compare( WC()-&gt;version, &#039;3.5.0&#039;, &#039;&lt;&#039; ) ) {
			return;
		}

		// If WC hasn&#039;t run the update routine yet we can hook into theirs to update subscriptions, otherwise we&#039;ll need to schedule our own update.
		if ( version_compare( get_option( &#039;woocommerce_db_version&#039; ), &#039;3.5.0&#039;, &#039;&lt;&#039; ) ) {
			self::$background_updaters[&#039;2.4&#039;][&#039;subscription_post_author&#039;]-&gt;hook_into_wc_350_update();
		} else if ( version_compare( self::$active_version, &#039;2.4.0&#039;, &#039;&lt;&#039; ) ) {
			self::$background_updaters[&#039;2.4&#039;][&#039;subscription_post_author&#039;]-&gt;schedule_repair();
		}
	}

	/**
	 * Used to check if a user ID is greater than the last user upgraded to version 1.4.
	 *
	 * Needs to be a separate function so that it can use a static variable (and therefore avoid calling get_option() thousands
	 * of times when iterating over thousands of users).
	 *
	 * @since 1.4
	 */
	public static function is_user_upgraded_to_1_4( $user_id ) {
		_deprecated_function( __METHOD__, &#039;2.0&#039;, &#039;WCS_Upgrade_1_4::is_user_upgraded( $user_id )&#039; );
		return WCS_Upgrade_1_4::is_user_upgraded( $user_id );
	}

	/**
	 * Display an admin notice if the database version is greater than the active version of the plugin by at least one minor release (eg 1.1 and 1.0).
	 *
	 * @since 2.3.0
	 * @deprecated 1.2.0
	 */
	public static function maybe_add_downgrade_notice() {
		wcs_deprecated_function( __METHOD__, &#039;1.2.0&#039; );

		// If there&#039;s no downgrade, exit early. self::$active_version is a bit of a misnomer here but in an upgrade context it refers to the database version of the plugin.
		if ( ! version_compare( wcs_get_minor_version_string( self::$active_version ), wcs_get_minor_version_string( WC_Subscriptions_Core_Plugin::instance()-&gt;get_plugin_version() ), &#039;&gt;&#039; ) ) {
			return;
		}

		$admin_notice = new WCS_Admin_Notice( &#039;error&#039; );
		$admin_notice-&gt;set_simple_content(
			sprintf(
				// translators: 1-2: opening/closing &lt;strong&gt; tags, 3: active version of Subscriptions, 4: current version of Subscriptions, 5-6: opening/closing tags linked to ticket form, 7-8: opening/closing tags linked to documentation.
				esc_html__( &#039;%1$sWarning!%2$s It appears that you have downgraded %1$sWooCommerce Subscriptions%2$s from %3$s to %4$s. Downgrading the plugin in this way may cause issues. Please update to %3$s or higher, or %5$sopen a new support ticket%6$s for further assistance. %7$sLearn more &amp;raquo;%8$s&#039;, &#039;woocommerce-subscriptions&#039; ),
				&#039;&lt;strong&gt;&#039;,
				&#039;&lt;/strong&gt;&#039;,
				&#039;&lt;code&gt;&#039; . self::$active_version . &#039;&lt;/code&gt;&#039;,
				&#039;&lt;code&gt;&#039; . WC_Subscriptions_Core_Plugin::instance()-&gt;get_plugin_version() . &#039;&lt;/code&gt;&#039;,
				&#039;&lt;a href=&quot;https://woocommerce.com/my-account/marketplace-ticket-form/&quot; target=&quot;_blank&quot;&gt;&#039;,
				&#039;&lt;/a&gt;&#039;,
				&#039;&lt;a href=&quot;https://docs.woocommerce.com/document/subscriptions/upgrade-instructions/#section-12&quot; target=&quot;_blank&quot;&gt;&#039;,
				&#039;&lt;/a&gt;&#039;
			)
		);

		$admin_notice-&gt;display();
	}
}
</code></pre>
            </article>
            </div>
        </div>
        <a href="#top" class="phpdocumentor-back-to-top"><i class="fas fa-chevron-circle-up"></i></a>

    </main>

    <footer class="phpdocumentor phpdocumentor-footer">
    <div class="phpdocumentor-section">
        <span>WooCommerce Code Reference API documentation generated by <a href="http://www.phpdoc.org/">phpDocumentor</a> on September 21st, 2022 at 05:39 am.</span>
    </div>
</footer>

    <script>
        cssVars({});
    </script>
    <script>
        var searchParams = {
            'searchIndex': '..\/js\/searchIndex.json'
        };
    </script>
    <script src="../js/searchIndex.js?updated=1663738776"></script>
    <script src="../js/search.js?updated=1663738776"></script>
</body>
</html>
