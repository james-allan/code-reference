<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WooCommerce Code Reference</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../images/favicon.png" />
    <link rel="apple-touch-icon" href="../images/apple-touch-icon.png"/>
    <link rel="apple-touch-icon" sizes="72x72" href="../images/apple-touch-icon-72x72.png"/>
    <link rel="apple-touch-icon" sizes="114x114" href="../images/apple-touch-icon-114x114.png"/>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/base.css?updated=1663738776">
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/template.css?updated=1663738776">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/css/all.min.css" integrity="sha256-ybRkN9dBjhcS2qrW1z+hfCxq+1aBdwyQM5wlQoQVt/0=" crossorigin="anonymous" />
            <script src="https://cdn.jsdelivr.net/npm/css-vars-ponyfill@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/js/all.min.js" integrity="sha256-0vuk8LXoyrmCjp1f0O300qo1M75ZQyhH9X3J6d+scmk=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tarekraafat/autocomplete.js@7.2.0/dist/js/autoComplete.min.js"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8KCYZ2CYMS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8KCYZ2CYMS', {
		'content_group' : 'WooCommerce Core Code Reference',
	});
</script>
        <script src="../js/prism.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            window.dispatchEvent(new HashChangeEvent('hashchange'));
        });
    </script>
</head>
<body id="top">
    <header class="phpdocumentor-top-header">
    <section class="phpdocumentor-section">
        <div class="site-branding">
            <a class="site-logo" href="../index.html"><img width="180" src="../images/logo.svg" alt="WooCommerce" /></a>
        </div>
        <nav class="main-navigation">
            <ul>
                <li><a href="../hooks/hooks.html">Hooks Reference</a></li>
                <li><a href="https://docs.woocommerce.com/">Documentation</a></li>
                <li><a href="https://woocommerce.github.io/woocommerce-rest-api-docs/">REST API Docs</a></li>
                <li><a href="https://woocommerce.com/careers/?utm_source=woocommerce+core+code+reference&utm_medium=devdocs&utm_campaign=woo+careers" target="_blank">We're hiring!</a></li>
            </ul>
        </nav>
    </section>
</header>

<div class="phpdocumentor-header">
    <section class="phpdocumentor-section">
        <h1 class="phpdocumentor-title">WooCommerce Code Reference</h1>
        <section class="phpdocumentor-search">
    <label class="phpdocumentor-label">
        <span class="visually-hidden">Search (click ESC to close search results)</span>
        <input id="autoComplete" tabindex="1" type="search" class="phpdocumentor-field phpdocumentor-search__field" placeholder="Loading..." disabled />
    </label>
</section>

    </section>
</div>

    <main class="phpdocumentor">
        <div class="phpdocumentor-section">
            <aside class="phpdocumentor-column -four phpdocumentor-sidebar">
    
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Namespaces</h2>
            </section>

        <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Packages</h2>
                    <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsAdmin.html"><abbr title="\WooCommerceSubscriptionsAdmin">WooCommerceSubscriptionsAdmin</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsClasses.html"><abbr title="\WooCommerceSubscriptionsClasses">WooCommerceSubscriptionsClasses</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptions.html"><abbr title="\WooCommerceSubscriptions">WooCommerceSubscriptions</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="../packages/WooCommerceSubscriptions-WC.html"><abbr title="\WooCommerceSubscriptions\WC">WC</abbr></a></li>
                                    <li><a href="../packages/WooCommerceSubscriptions-RestApi.html"><abbr title="\WooCommerceSubscriptions\RestApi">RestApi</abbr></a></li>
                                    <li><a href="../packages/WooCommerceSubscriptions-WCS.html"><abbr title="\WooCommerceSubscriptions\WCS">WCS</abbr></a></li>
                                    <li><a href="../packages/WooCommerceSubscriptions-GatewaysPayPal.html"><abbr title="\WooCommerceSubscriptions\GatewaysPayPal">GatewaysPayPal</abbr></a></li>
                                    <li><a href="../packages/WooCommerceSubscriptions-Privacy.html"><abbr title="\WooCommerceSubscriptions\Privacy">Privacy</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerce.html"><abbr title="\WooCommerce">WooCommerce</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="../packages/WooCommerce-SubscriptionsAPI.html"><abbr title="\WooCommerce\SubscriptionsAPI">SubscriptionsAPI</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-SubscriptionsIncludesEmails.html"><abbr title="\WooCommerce\SubscriptionsIncludesEmails">SubscriptionsIncludesEmails</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-SubscriptionsClassesEmails.html"><abbr title="\WooCommerce\SubscriptionsClassesEmails">SubscriptionsClassesEmails</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WC.html"><abbr title="\WC">WC</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="../packages/WC-Subscriptions.html"><abbr title="\WC\Subscriptions">Subscriptions</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsAdminUpgrades.html"><abbr title="\WooCommerceSubscriptionsAdminUpgrades">WooCommerceSubscriptionsAdminUpgrades</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsFunctions.html"><abbr title="\WooCommerceSubscriptionsFunctions">WooCommerceSubscriptionsFunctions</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsAdminMetaBoxes.html"><abbr title="\WooCommerceSubscriptionsAdminMetaBoxes">WooCommerceSubscriptionsAdminMetaBoxes</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsAbstracts.html"><abbr title="\WooCommerceSubscriptionsAbstracts">WooCommerceSubscriptionsAbstracts</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceSubscriptionsIncludes.html"><abbr title="\WooCommerceSubscriptionsIncludes">WooCommerceSubscriptionsIncludes</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerceClassesEmails.html"><abbr title="\WooCommerceClassesEmails">WooCommerceClassesEmails</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/SkyVergeWooCommerceAPI.html"><abbr title="\SkyVergeWooCommerceAPI">SkyVergeWooCommerceAPI</abbr></a></h3>
                        </section>
    
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Reports</h2>
                <h3 class="phpdocumentor-sidebar__root-package"><a href="../reports/deprecated.html">Deprecated</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../reports/errors.html">Errors</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../reports/markers.html">Markers</a></h3>
    </section>

    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Indices</h2>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../indices/files.html">Files</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../hooks/hooks.html">Hooks Reference</a></h3>
    </section>
</aside>

            <div class="phpdocumentor-column -eight phpdocumentor-content">
                    <ul class="phpdocumentor-breadcrumbs">
            <li class="phpdocumentor-breadcrumb"><a href="../packages/WooCommerceSubscriptionsAdminUpgrades.html">WooCommerceSubscriptionsAdminUpgrades</a></li>
    </ul>

    <article class="phpdocumentor-element -file">
        <h2 class="phpdocumentor-content__title">class-wcs-repair-2-0-2.php</h2>

                

        
                    <h3 class="phpdocumentor-elements__header" id="source-code">
                Source code
                <a href="#source-code" class="headerlink"><i class="fas fa-link"></i></a>
            </h3>
            <pre id="source-view" tabindex="-1" class="language-php line-numbers linkable-line-numbers"><code>&lt;?php
/**
 * Repair subscriptions data corrupted with the v2.0.0 upgrade process
 *
 * @author      Prospress
 * @category    Admin
 * @package     WooCommerce Subscriptions/Admin/Upgrades
 * @version     2.0.2
 */

if ( ! defined( &#039;ABSPATH&#039; ) ) {
	exit; // Exit if accessed directly
}

class WCS_Repair_2_0_2 {

	/**
	 * Get a batch of subscriptions subscriptions that haven&#039;t already been checked for repair.
	 *
	 * @return array IDs of subscription that have not been checked or repaired
	 */
	public static function get_subscriptions_to_repair( $batch_size ) {

		// Get any subscriptions that haven&#039;t already been checked for repair
		$subscription_ids_to_repair = get_posts( array(
			&#039;post_type&#039;      =&gt; &#039;shop_subscription&#039;,
			&#039;post_status&#039;    =&gt; &#039;any&#039;,
			&#039;posts_per_page&#039; =&gt; $batch_size,
			&#039;fields&#039;         =&gt; &#039;ids&#039;,
			&#039;orderby&#039;        =&gt; &#039;ID&#039;,
			&#039;order&#039;          =&gt; &#039;ASC&#039;,
			&#039;meta_query&#039;     =&gt; array(
				array(
					&#039;key&#039;     =&gt; &#039;_wcs_repaired_2_0_2&#039;,
					&#039;compare&#039; =&gt; &#039;NOT EXISTS&#039;,
				),
			),
		) );

		return $subscription_ids_to_repair;
	}

	/**
	 * Update any subscription that need to be repaired.
	 *
	 * @return array The counts of repaired and unrepaired subscriptions
	 */
	public static function maybe_repair_subscriptions( $subscription_ids_to_repair ) {
		global $wpdb;

		// don&#039;t allow data to be half upgraded on a subscription in case of a script timeout or other non-recoverable error
		$wpdb-&gt;query( &#039;START TRANSACTION&#039; );

		$repaired_count = $unrepaired_count = 0;

		foreach ( $subscription_ids_to_repair as $subscription_id ) {

			$subscription = wcs_get_subscription( $subscription_id );

			if ( false !== $subscription &amp;&amp; self::maybe_repair_subscription( $subscription ) ) {
				WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: repair completed&#039;, $subscription-&gt;get_id() ) );
				$repaired_count++;
				update_post_meta( $subscription_id, &#039;_wcs_repaired_2_0_2&#039;, &#039;true&#039; );
			} else {
				WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: no repair needed&#039;, $subscription-&gt;get_id() ) );
				$unrepaired_count++;
				update_post_meta( $subscription_id, &#039;_wcs_repaired_2_0_2&#039;, &#039;false&#039; );
			}
		}

		$wpdb-&gt;query( &#039;COMMIT&#039; );

		return array(
			&#039;repaired_count&#039;   =&gt; $repaired_count,
			&#039;unrepaired_count&#039; =&gt; $unrepaired_count,
		);

	}

	/**
	 * Check if a subscription was created prior to 2.0.0 and has some dates that need to be updated
	 * because the meta was borked during the 2.0.0 upgrade process. If it does, then update the dates
	 * to the new values.
	 *
	 * @return bool true if the subscription was repaired, otherwise false
	 */
	protected static function maybe_repair_subscription( $subscription ) {

		$repaired_subscription = false;
		$parent_order          = $subscription-&gt;get_parent();

		// if the subscription doesn&#039;t have an order, it must have been created in 2.0, so we can ignore it
		if ( false === $parent_order ) {
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: no need to repair: it has no order.&#039;, $subscription-&gt;get_id() ) );
			return $repaired_subscription;
		}

		$subscription_line_items = $subscription-&gt;get_items();

		// if the subscription has more than one line item, it must have been created in 2.0, so we can ignore it
		if ( count( $subscription_line_items ) &gt; 1 ) {
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: no need to repair: it has more than one line item.&#039;, $subscription-&gt;get_id() ) );
			return $repaired_subscription;
		}

		$subscription_line_item_id = key( $subscription_line_items );
		$subscription_line_item    = array_shift( $subscription_line_items );

		// Get old order item&#039;s meta
		foreach ( $parent_order-&gt;get_items() as $line_item_id =&gt; $line_item ) {
			if ( wcs_get_canonical_product_id( $line_item ) == wcs_get_canonical_product_id( $subscription_line_item ) ) {
				$matching_line_item_id = $line_item_id;
				$matching_line_item    = $line_item;
				break;
			}
		}

		// we couldn&#039;t find a matching line item so we can&#039;t repair it
		if ( ! isset( $matching_line_item ) ) {
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: can not repair: it has no matching line item.&#039;, $subscription-&gt;get_id() ) );
			return $repaired_subscription;
		}

		$matching_line_item_meta = $matching_line_item[&#039;item_meta&#039;];

		// if the order item doesn&#039;t have migrated subscription data, the subscription wasn&#039;t migrated from 1.5
		if ( ! isset( $matching_line_item_meta[&#039;_wcs_migrated_subscription_status&#039;] ) &amp;&amp; ! isset( $matching_line_item_meta[&#039;_wcs_migrated_subscription_start_date&#039;] ) ) {
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: no need to repair: matching line item has no migrated meta data.&#039;, $subscription-&gt;get_id() ) );
			return $repaired_subscription;
		}

		if ( false !== self::maybe_repair_line_tax_data( $subscription_line_item_id, $matching_line_item_id, $matching_line_item ) ) {
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: repaired missing line tax data.&#039;, $subscription-&gt;get_id() ) );
			$repaired_subscription = true;
		} else {
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: line tax data not added.&#039;, $subscription-&gt;get_id() ) );
		}

		// if the subscription has been cancelled, we don&#039;t need to repair any other data
		if ( $subscription-&gt;has_status( array( &#039;pending-cancel&#039;, &#039;cancelled&#039; ) ) ) {
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: no need to repair: it has cancelled status.&#039;, $subscription-&gt;get_id() ) );
			return $repaired_subscription;
		}

		$dates_to_update = array();

		if ( false !== ( $repair_date = self::check_trial_end_date( $subscription, $matching_line_item_meta ) ) ) {
			$dates_to_update[&#039;trial_end&#039;] = $repair_date;
		}

		if ( false !== ( $repair_date = self::check_next_payment_date( $subscription ) ) ) {
			$dates_to_update[&#039;next_payment&#039;] = $repair_date;
		}

		if ( false !== ( $repair_date = self::check_end_date( $subscription, $matching_line_item_meta ) ) ) {
			$dates_to_update[&#039;end&#039;] = $repair_date;
		}

		if ( ! empty( $dates_to_update ) ) {

			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: repairing dates = %s&#039;, $subscription-&gt;get_id(), str_replace( array( &#039;{&#039;, &#039;}&#039;, &#039;&quot;&#039; ), &#039;&#039;, wcs_json_encode( $dates_to_update ) ) ) );

			try {
				$subscription-&gt;update_dates( $dates_to_update );
				WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: repaired dates = %s&#039;, $subscription-&gt;get_id(), str_replace( array( &#039;{&#039;, &#039;}&#039;, &#039;&quot;&#039; ), &#039;&#039;, wcs_json_encode( $dates_to_update ) ) ) );
			} catch ( Exception $e ) {
				WCS_Upgrade_Logger::add( sprintf( &#039;!! For subscription %d: unable to repair dates (%s), exception &quot;%s&quot;&#039;, $subscription-&gt;get_id(), str_replace( array( &#039;{&#039;, &#039;}&#039;, &#039;&quot;&#039; ), &#039;&#039;, wcs_json_encode( $dates_to_update ) ), $e-&gt;getMessage() ) );
			}

			try {
				self::maybe_repair_status( $subscription, $matching_line_item_meta, $dates_to_update );
			} catch ( Exception $e ) {
				WCS_Upgrade_Logger::add( sprintf( &#039;!! For subscription %d: unable to repair status. Exception: &quot;%s&quot;&#039;, $subscription-&gt;get_id(), $e-&gt;getMessage() ) );
			}

			$repaired_subscription = true;
		}

		if ( &#039;&#039; !== wcs_get_objects_property( $parent_order, &#039;customer_note&#039; ) &amp;&amp; &#039;&#039; == $subscription-&gt;get_customer_note() ) {

			$post_data = array(
				&#039;ID&#039;           =&gt; $subscription-&gt;get_id(),
				&#039;post_excerpt&#039; =&gt; wcs_get_objects_property( $parent_order, &#039;customer_note&#039; ),
			);

			$updated_post_id = wp_update_post( $post_data, true );

			if ( ! is_wp_error( $updated_post_id ) ) {
				WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: repaired missing customer note.&#039;, $subscription-&gt;get_id() ) );
				$repaired_subscription = true;
			} else {
				WCS_Upgrade_Logger::add( sprintf( &#039;!! For subscription %d: unable to repair missing customer note. Exception: &quot;%s&quot;&#039;, $subscription-&gt;get_id(), $updated_post_id-&gt;get_error_message() ) );
			}
		}

		return $repaired_subscription;
	}

	/**
	 * If we have a trial end date and that value is not the same as the old end date prior to upgrade, it was most likely
	 * corrupted, so we will reset it to the value in meta.
	 *
	 * @param  WC_Subscription $subscription the subscription to check
	 * @param  array $former_order_item_meta the order item meta data for the line item on the original order that formerly represented the subscription
	 * @return string|bool false if the date does not need to be repaired or the new date if it should be repaired
	 */
	protected static function check_trial_end_date( $subscription, $former_order_item_meta ) {

		$new_trial_end_time = $subscription-&gt;get_time( &#039;trial_end&#039; );

		if ( $new_trial_end_time &gt; 0 ) {

			$old_trial_end_date = isset( $former_order_item_meta[&#039;_wcs_migrated_subscription_trial_expiry_date&#039;][0] ) ? $former_order_item_meta[&#039;_wcs_migrated_subscription_trial_expiry_date&#039;][0] : 0;

			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: new trial end date = %s.&#039;, $subscription-&gt;get_id(), var_export( $subscription-&gt;get_date( &#039;trial_end&#039; ), true ) ) );
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: old trial end date = %s.&#039;, $subscription-&gt;get_id(), var_export( $old_trial_end_date, true ) ) );

			// if the subscription has a trial end time whereas previously it didn&#039;t, we need it to be deleted
			if ( 0 == $old_trial_end_date ) {
				$repair_date = 0;
			} else {
				$repair_date = false;
			}
		} else {
			$repair_date = false;
		}

		WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: repair trial end date = %s.&#039;, $subscription-&gt;get_id(), var_export( $repair_date, true ) ) );

		return $repair_date;
	}

	/**
	 * Because the upgrader may have attempted to set an invalid end date on the subscription, it could
	 * lead to the entire date update process failing, which would mean that a next payment date would
	 * not be set even when one existed.
	 *
	 * This method checks if a given subscription has no next payment date, and if it doesn&#039;t, it checks
	 * if one was previously scheduled for the old subscription. If one was, and that date is in the future,
	 * it will pass that date back for being set on the subscription. If a date was scheduled but that is now
	 * in the past, it will recalculate it.
	 *
	 * @param  WC_Subscription $subscription the subscription to check
	 * @return string|bool false if the date does not need to be repaired or the new date if it should be repaired
	 */
	protected static function check_next_payment_date( $subscription ) {
		global $wpdb;

		// the subscription doesn&#039;t have a next payment date set, let&#039;s see if it should
		if ( 0 == $subscription-&gt;get_time( &#039;next_payment&#039; ) &amp;&amp; $subscription-&gt;has_status( &#039;active&#039; ) ) {

			$old_hook_args = array(
				&#039;user_id&#039;          =&gt; (int) $subscription-&gt;get_user_id(),
				&#039;subscription_key&#039; =&gt; wcs_get_old_subscription_key( $subscription ),
			);

			// get the latest scheduled subscription payment in v1.5
			$old_next_payment_date = $wpdb-&gt;get_var( $wpdb-&gt;prepare(
				&quot;SELECT post_date_gmt FROM $wpdb-&gt;posts
				 WHERE post_type = %s
				 AND post_content = %s
				 AND post_title = &#039;scheduled_subscription_payment&#039;
				 ORDER BY post_date_gmt DESC&quot;,
				ActionScheduler_wpPostStore::POST_TYPE,
				wcs_json_encode( $old_hook_args )
			) );

			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: new next payment date = %s.&#039;, $subscription-&gt;get_id(), var_export( $subscription-&gt;get_date( &#039;next_payment&#039; ), true ) ) );
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: old next payment date = %s.&#039;, $subscription-&gt;get_id(), var_export( $old_next_payment_date, true ) ) );

			// if we have a date, make sure it&#039;s valid
			if ( null !== $old_next_payment_date ) {
				if ( wcs_date_to_time( $old_next_payment_date ) &lt;= gmdate( &#039;U&#039; ) ) {
					$repair_date = $subscription-&gt;calculate_date( &#039;next_payment&#039; );
					if ( 0 == $repair_date ) {
						$repair_date = false;
					}
					WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: old next payment date is in the past, setting it to %s.&#039;, $subscription-&gt;get_id(), var_export( $repair_date, true ) ) );
				} else {
					$repair_date = $old_next_payment_date;
				}
			} else {

				// let&#039;s just double check we shouldn&#039;t have a date set by recalculating it
				$calculated_next_payment_date = $subscription-&gt;calculate_date( &#039;next_payment&#039; );

				if ( 0 != $calculated_next_payment_date &amp;&amp; wcs_date_to_time( $calculated_next_payment_date ) &gt; gmdate( &#039;U&#039; ) ) {
					$repair_date = $calculated_next_payment_date;
				} else {
					$repair_date = false;
				}

				WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: no old next payment date, setting it to %s.&#039;, $subscription-&gt;get_id(), var_export( $repair_date, true ) ) );
			}
		} else {
			$repair_date = false;
		}

		WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: repair next payment date = %s.&#039;, $subscription-&gt;get_id(), var_export( $repair_date, true ) ) );

		return $repair_date;
	}

	/**
	 * Check if the old subscription meta had an end date recorded and make sure that end date is now being used for the new subscription.
	 *
	 * In Subscriptions prior to 2.0 a subscription could have both an end date and an expiration date. The end date represented a date in the past
	 * on which the subscription expired or was cancelled. The expiration date represented a date on which the subscription was set to expire (this
	 * could be in the past or future and could be the same as the end date or different). Because the end date is a definitive even, in this function
	 * we first check if it exists before falling back to the expiration date to check against.
	 *
	 * @param  WC_Subscription $subscription the subscription to check
	 * @param  array $former_order_item_meta the order item meta data for the line item on the original order that formerly represented the subscription
	 * @return string|bool false if the date does not need to be repaired or the new date if it should be repaired
	 */
	protected static function check_end_date( $subscription, $former_order_item_meta ) {

		$new_end_time = $subscription-&gt;get_time( &#039;end&#039; );

		if ( $new_end_time &gt; 0 ) {

			$old_end_date = isset( $former_order_item_meta[&#039;_wcs_migrated_subscription_end_date&#039;][0] ) ? $former_order_item_meta[&#039;_wcs_migrated_subscription_end_date&#039;][0] : 0;

			// if the subscription hadn&#039;t expired or been cancelled yet, it wouldn&#039;t have an end date, but it may still have had an expiry date, so use that instead
			if ( 0 == $old_end_date ) {
				$old_end_date = isset( $former_order_item_meta[&#039;_wcs_migrated_subscription_expiry_date&#039;][0] ) ? $former_order_item_meta[&#039;_wcs_migrated_subscription_expiry_date&#039;][0] : 0;
			}

			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: new end date = %s.&#039;, $subscription-&gt;get_id(), var_export( $subscription-&gt;get_date( &#039;end&#039; ), true ) ) );
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: old end date = %s.&#039;, $subscription-&gt;get_id(), var_export( $old_end_date, true ) ) );

			// if the subscription has an end time whereas previously it didn&#039;t, we need it to be deleted so set it 0
			if ( 0 == $old_end_date ) {
				$repair_date = 0;
			} else {
				$repair_date = false;
			}
		} else {
			$repair_date = false;
		}

		WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: repair end date = %s.&#039;, $subscription-&gt;get_id(), var_export( $repair_date, true ) ) );

		return $repair_date;
	}

	/**
	 * If the subscription has expired since upgrading and the end date is not the original expiration date,
	 * we need to unexpire it, which in the case of a previously active subscription means activate it, and
	 * in any other case, leave it as on-hold (a cancelled subscription wouldn&#039;t have been expired, so the
	 * status must be on-hold or active).
	 *
	 * @param  WC_Subscription $subscription data about the subscription
	 * @return bool true if the trial date was repaired, otherwise false
	 */
	protected static function maybe_repair_status( $subscription, $former_order_item_meta, $dates_to_update ) {

		if ( $subscription-&gt;has_status( &#039;expired&#039; ) &amp;&amp; &#039;expired&#039; != $former_order_item_meta[&#039;_wcs_migrated_subscription_status&#039;][0] &amp;&amp; isset( $dates_to_update[&#039;end&#039;] ) ) {

			try {

				// we need to bypass the update_status() method here because normally an expired subscription can&#039;t have it&#039;s status changed, we also don&#039;t want normal status change hooks to be fired
				wp_update_post(
					array(
						&#039;ID&#039;          =&gt; $subscription-&gt;get_id(),
						&#039;post_status&#039; =&gt; &#039;wc-on-hold&#039;,
					)
				);

				// if the payment method doesn&#039;t support date changes, we still want to reactivate the subscription but we also need to process a special failed payment at the next renewal to fix up the payment method so we&#039;ll set a special flag in post meta to handle that
				if ( ! $subscription-&gt;payment_method_supports( &#039;subscription_date_changes&#039; ) &amp;&amp; $subscription-&gt;get_total() &gt; 0 ) {
					update_post_meta( $subscription-&gt;get_id(), &#039;_wcs_repaired_2_0_2_needs_failed_payment&#039;, &#039;true&#039; );
					WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: payment method does not support &quot;subscription_date_changes&quot; and total &gt; 0, setting &quot;_wcs_repaired_2_0_2_needs_failed_payment&quot; post meta flag.&#039;, $subscription-&gt;get_id() ) );
				}

				if ( &#039;active&#039; == $former_order_item_meta[&#039;_wcs_migrated_subscription_status&#039;][0] &amp;&amp; $subscription-&gt;can_be_updated_to( &#039;active&#039; ) ) {
					$subscription-&gt;update_status( &#039;active&#039; );
				}

				WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: repaired status. Status was &quot;expired&quot;, it is now &quot;%s&quot;.&#039;, $subscription-&gt;get_id(), $subscription-&gt;get_status() ) );
				$repair_status = true;

			} catch ( Exception $e ) {
				WCS_Upgrade_Logger::add( sprintf( &#039;!!! For subscription %d: unable to repair status, exception &quot;%s&quot;&#039;, $subscription-&gt;get_id(), $e-&gt;getMessage() ) );
				$repair_status = false;
			}
		} else {
			WCS_Upgrade_Logger::add( sprintf( &#039;For subscription %d: no need to repair status, current status: %s; former status: %s.&#039;, $subscription-&gt;get_id(), $subscription-&gt;get_status(), $former_order_item_meta[&#039;_wcs_migrated_subscription_status&#039;][0] ) );
			$repair_status = false;
		}
		return $repair_status;
	}

	/**
	 * There was a bug in the WCS_Upgrade_2_0::add_line_tax_data() method in Subscriptions 2.0.0 and 2.0.1 which
	 * prevented recurring line tax data from being copied correctly to newly created subscriptions. This bug was
	 * fixed in 2.0.2, so we can now use that method to make sure line tax data is set correctly. But to do that,
	 * we first need to massage some of the deprecated line item meta to use the original meta keys.
	 *
	 * @param  int $subscription_line_item_id ID of the new subscription line item
	 * @param  int $old_order_item_id ID of the old order line item
	 * @param  array $old_order_item The old line item
	 * @return bool|int the meta ID of the newly added &#039;_line_tax_data&#039; meta data row, or false if no line tax data was added.
	 */
	protected static function maybe_repair_line_tax_data( $subscription_line_item_id, $old_order_item_id, $old_order_item ) {

		// we need item meta in the old format so that we can use the (now fixed) WCS_Upgrade_2_0::add_line_tax_data() method and save duplicating its code
		$old_order_item[&#039;item_meta&#039;][&#039;_recurring_line_total&#039;]        = isset( $old_order_item[&#039;item_meta&#039;][&#039;_wcs_migrated_recurring_line_total&#039;] ) ? $old_order_item[&#039;item_meta&#039;][&#039;_wcs_migrated_recurring_line_total&#039;] : 0;
		$old_order_item[&#039;item_meta&#039;][&#039;_recurring_line_tax&#039;]          = isset( $old_order_item[&#039;item_meta&#039;][&#039;_wcs_migrated_recurring_line_tax&#039;] ) ? $old_order_item[&#039;item_meta&#039;][&#039;_wcs_migrated_recurring_line_tax&#039;] : 0;
		$old_order_item[&#039;item_meta&#039;][&#039;_recurring_line_subtotal_tax&#039;] = isset( $old_order_item[&#039;item_meta&#039;][&#039;_wcs_migrated_recurring_line_subtotal_tax&#039;] ) ? $old_order_item[&#039;item_meta&#039;][&#039;_wcs_migrated_recurring_line_subtotal_tax&#039;] : 0;

		if ( isset( $old_order_item[&#039;item_meta&#039;][&#039;_wcs_migrated_recurring_line_tax_data&#039;] ) ) {
			$old_order_item[&#039;item_meta&#039;][&#039;_recurring_line_tax_data&#039;] = $old_order_item[&#039;item_meta&#039;][&#039;_wcs_migrated_recurring_line_tax_data&#039;];
		}

		return WCS_Upgrade_2_0::add_line_tax_data( $subscription_line_item_id, $old_order_item_id, $old_order_item );
	}
}
</code></pre>
            </article>
            </div>
        </div>
        <a href="#top" class="phpdocumentor-back-to-top"><i class="fas fa-chevron-circle-up"></i></a>

    </main>

    <footer class="phpdocumentor phpdocumentor-footer">
    <div class="phpdocumentor-section">
        <span>WooCommerce Code Reference API documentation generated by <a href="http://www.phpdoc.org/">phpDocumentor</a> on September 21st, 2022 at 05:39 am.</span>
    </div>
</footer>

    <script>
        cssVars({});
    </script>
    <script>
        var searchParams = {
            'searchIndex': '..\/js\/searchIndex.json'
        };
    </script>
    <script src="../js/searchIndex.js?updated=1663738776"></script>
    <script src="../js/search.js?updated=1663738776"></script>
</body>
</html>
